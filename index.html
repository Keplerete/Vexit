<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>VexiT — Вызов транскодирования</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

  /* Общий стиль и фон с сеткой и анимацией точек */
  body {
    margin: 0;
    font-family: 'Share Tech Mono', monospace, 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    min-height: 100vh;
    background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
    color: #eee;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    overflow-x: hidden;
    position: relative;
  }

  /* Полупрозрачная сетка поверх фона */
  body::before {
    content: "";
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    background:
      linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
      linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
    background-size: 30px 30px;
    z-index: 0;
  }

  /* Анимация точек и линий (сетка сети) */
  .network-canvas {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index: 0;
    mix-blend-mode: screen;
  }

  header {
    font-size: 3rem;
    font-weight: 900;
    letter-spacing: 0.15em;
    margin-bottom: 10px;
    color: #66ccff;
    user-select: none;
    position: relative;
    z-index: 2;
    text-shadow:
      0 0 5px #66ccff,
      0 0 15px #66ccff;
  }
  header span {
    color: #ffaa00;
    text-shadow:
      0 0 8px #ffaa00,
      0 0 20px #ffaa00;
  }
  p.description {
    font-size: 1.25rem;
    max-width: 600px;
    margin-bottom: 30px;
    line-height: 1.5;
    text-align: center;
    position: relative;
    z-index: 2;
  }
  .translator {
    background: rgba(255 255 255 / 0.05);
    padding: 20px;
    border-radius: 12px;
    box-shadow:
      0 0 20px #ffaa00cc,
      inset 0 0 15px #ffaa00bb;
    width: 100%;
    max-width: 700px;
    position: relative;
    z-index: 2;
    transition: box-shadow 0.6s ease-in-out;
  }
  .translator:hover {
    box-shadow:
      0 0 30px #ffbb33dd,
      inset 0 0 25px #ffbb33dd;
  }
  label {
    font-weight: 700;
    display: block;
    margin-bottom: 6px;
    color: #ffaa00;
  }
  textarea, select {
    width: 100%;
    padding: 12px 15px;
    font-size: 1rem;
    border-radius: 8px;
    border: none;
    background: #111f2a;
    color: #eee;
    resize: vertical;
    box-sizing: border-box;
    box-shadow:
      inset 0 0 6px #223344aa;
    font-family: 'Share Tech Mono', monospace;
    transition: box-shadow 0.3s ease;
  }
  textarea:focus, select:focus {
    outline: none;
    box-shadow:
      0 0 15px #ffaa00cc,
      inset 0 0 10px #ffaa00cc;
    background: #1a2b3c;
  }
  textarea {
    min-height: 100px;
    margin-bottom: 20px;
  }
  select, input[type=checkbox] {
    margin-bottom: 20px;
  }
  button.translate-btn {
    background-color: #ffaa00;
    border: none;
    color: #111;
    font-size: 1.25rem;
    font-weight: 700;
    padding: 15px 40px;
    border-radius: 30px;
    cursor: pointer;
    box-shadow:
      0 0 15px #ffaa00aa,
      0 0 30px #ffaa00bb;
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
    width: 100%;
    user-select: none;
  }
  button.translate-btn:hover {
    background-color: #ffbb33;
    box-shadow:
      0 0 35px #ffbb33cc,
      0 0 50px #ffbb33ee;
  }
  #output {
    margin-top: 25px;
    background: #111f2a;
    padding: 20px;
    border-radius: 12px;
    min-height: 150px;
    white-space: pre-wrap;
    font-family: 'Share Tech Mono', monospace;
    color: #ccf3ff;
    box-shadow:
      inset 0 0 15px #33aaffaa;
    transition: box-shadow 0.3s ease;
  }
  #output:hover {
    box-shadow:
      inset 0 0 25px #66ccffdd;
  }
  footer {
    margin-top: auto;
    font-size: 0.85rem;
    color: #999;
    padding: 10px 0;
    text-align: center;
    width: 100%;
    position: relative;
    z-index: 2;
  }
  a {
    color: #66ccff;
    text-decoration: none;
  }
  a:hover {
    text-decoration: underline;
  }
  .inline-label {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 20px;
    color: #ffaa00;
    font-weight: 700;
  }
  .version-select {
    margin-bottom: 20px;
  }
</style>
</head>
<body>

<header>Vex<span>i</span>T</header>

<p class="description">
  Инновационный онлайн-сервис для перевода текста в различные системы кодирования — от классических двоичных и троичных до уникальных кастомных и инопланетных форматов.<br>
  Преобразуй информацию с лёгкостью и стилем, открывая новые горизонты цифровой коммуникации.
</p>

<div class="translator" id="translator">
  <label for="textInput">Введите текст для перевода или декодирования:</label>
  <textarea id="textInput" placeholder="Например: Привет, мир!"></textarea>

  <label for="baseSelect">Выберите систему кодирования:</label>
  <select id="baseSelect">
    <option value="2">Двоичный (основание 2)</option>
    <option value="3">Троичный (основание 3)</option>
    <option value="4">Четвертичный (основание 4)</option>
    <option value="5">Пятеричный (основание 5)</option>
    <option value="custom" selected>Кастомный инопланетный код (основание 7)</option>
  </select>

  <div class="inline-label">
    <input type="checkbox" id="decodeToggle" />
    <label for="decodeToggle" style="user-select:none;">Декодировать (из кода в текст)</label>
  </div>

  <label for="versionSelect">Версия отображения:</label>
  <select id="versionSelect" class="version-select">
    <option value="vertical" selected>Вертикальная (по одной строке на символ)</option>
    <option value="horizontal">Горизонтальная (все коды подряд через пробел)</option>
  </select>

  <button class="translate-btn" onclick="convert()">Выполнить</button>

  <pre id="output"></pre>
</div>

<!-- Canvas для сетки и точек -->
<canvas class="network-canvas" id="networkCanvas"></canvas>

<footer>
  © 2025 VexiT. Все права защищены.<br>
  Контакты: <a href="https://t.me/corecmd" target="_blank" rel="noopener noreferrer">@corecmd</a>
</footer>

<script>
  const customSymbols = ['0', '∆', '⧫', '☌', '⚛', '✦', '※']; // Кастомные символы для основания 7

  // Конвертация числа в кастомную систему
  function toCustomBase(num, baseSymbols) {
    const base = baseSymbols.length;
    if (num === 0) return baseSymbols[0];
    let result = '';
    let n = num;
    while (n > 0) {
      const digit = n % base;
      result = baseSymbols[digit] + result;
      n = Math.floor(n / base);
    }
    return result;
  }

  // Конвертация числа в стандартную систему с паддингом
  function toStandardBase(num, base, padLength) {
    let str = num.toString(base);
    return str.padStart(padLength, '0');
  }

  // Декодирование из кастомной системы обратно в число
  function fromCustomBase(str, baseSymbols) {
    const base = baseSymbols.length;
    let result = 0;
    for (let i = 0; i < str.length; i++) {
      const digit = baseSymbols.indexOf(str[i]);
      if (digit === -1) return NaN; // Неизвестный символ
      result = result * base + digit;
    }
    return result;
  }

  // Декодирование из строки по основанию в число
  function fromStandardBase(str, base) {
    return parseInt(str, base);
  }

  // Подсчет паддинга длины для ровного вывода
  function getPadLength(base) {
    if (base === 'custom') {
      return 4; // для базы 7 и 2 байт символов
    } else {
      const baseNum = Number(base);
      return Math.ceil(Math.log(65535) / Math.log(baseNum));
    }
  }

  // Разбиение строки для декодирования
  function splitCodes(inputStr, padLength, base, version) {
    let codes = [];

    if (version === 'vertical') {
      codes = inputStr.trim().split(/\r?\n/);
    } else {
      codes = inputStr.trim().split(/\s+/);
    }

    // В случае кастомного кода в горизонтальном режиме разбиваем по длине
    if (base === 'custom' && version === 'horizontal') {
      const joined = inputStr.replace(/\s+/g, '');
      codes = [];
      for (let i = 0; i < joined.length; i += padLength) {
        codes.push(joined.slice(i, i + padLength));
      }
    }
    return codes;
  }

  function convert() {
    const input = document.getElementById('textInput').value.trim();
    const base = document.getElementById('baseSelect').value;
    const output = document.getElementById('output');
    const decode = document.getElementById('decodeToggle').checked;
    const version = document.getElementById('versionSelect').value;

    if (!input) {
      output.textContent = 'Пожалуйста, введите текст для перевода или декодирования.';
      return;
    }

    const padLength = getPadLength(base);
    let result = '';

    if (!decode) {
      // Кодирование: текст → код
      if (version === 'vertical') {
        for (let i = 0; i < input.length; i++) {
          const char = input[i];
          const code = input.charCodeAt(i);
          let encoded;

          if (base === 'custom') {
            encoded = toCustomBase(code, customSymbols).padStart(padLength, customSymbols[0]);
          } else {
            encoded = toStandardBase(code, Number(base), padLength);
          }

          result += `${char} → ${encoded}\n`;
        }
      } else {
        // Горизонтальный: все коды подряд через пробел
        let codes = [];
        for (let i = 0; i < input.length; i++) {
          const code = input.charCodeAt(i);
          let encoded;

          if (base === 'custom') {
            encoded = toCustomBase(code, customSymbols).padStart(padLength, customSymbols[0]);
          } else {
            encoded = toStandardBase(code, Number(base), padLength);
          }
          codes.push(encoded);
        }
        result = codes.join(' ');
      }
    } else {
      // Декодирование: код → текст
      const codes = splitCodes(input, padLength, base, version);

      let chars = [];
      for (const codeStr of codes) {
        if (!codeStr.trim()) continue;

        let num;
        if (base === 'custom') {
          num = fromCustomBase(codeStr, customSymbols);
        } else {
          num = fromStandardBase(codeStr, Number(base));
        }
        if (isNaN(num) || num < 0 || num > 65535) {
          output.textContent = `Ошибка: некорректный код '${codeStr}'`;
          return;
        }
        chars.push(String.fromCharCode(num));
      }
      result = chars.join('');
    }

    output.textContent = result;
  }

  // --- Анимация сетки с точками ---

  const canvas = document.getElementById('networkCanvas');
  const ctx = canvas.getContext('2d');
  let width, height;
  let points = [];
  const pointCount = 60;
  const maxDistance = 140;

  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
  }

  window.addEventListener('resize', resize);
  resize();

  // Создаем точки с координатами и скоростью
  function createPoints() {
    points = [];
    for (let i = 0; i < pointCount; i++) {
      points.push({
        x: Math.random() * width,
        y: Math.random() * height,
        vx: (Math.random() - 0.5) * 0.3,
        vy: (Math.random() - 0.5) * 0.3,
        radius: 1.2 + Math.random() * 1.5,
      });
    }
  }
  createPoints();

  function draw() {
    ctx.clearRect(0, 0, width, height);

    // Рисуем линии между близкими точками
    for (let i = 0; i < points.length; i++) {
      for (let j = i + 1; j < points.length; j++) {
        const dx = points[i].x - points[j].x;
        const dy = points[i].y - points[j].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < maxDistance) {
          const alpha = 1 - dist / maxDistance;
          ctx.strokeStyle = `rgba(255, 170, 0, ${alpha * 0.3})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(points[i].x, points[i].y);
          ctx.lineTo(points[j].x, points[j].y);
          ctx.stroke();
        }
      }
    }

    // Рисуем точки
    for (let p of points) {
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255, 170, 0, 0.7)';
      ctx.shadowColor = '#ffaa00';
      ctx.shadowBlur = 8;
      ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }

  function update() {
    for (let p of points) {
      p.x += p.vx;
      p.y += p.vy;
      if (p.x < 0 || p.x > width) p.vx *= -1;
      if (p.y < 0 || p.y > height) p.vy *= -1;
    }
  }

  function animate() {
    update();
    draw();
    requestAnimationFrame(animate);
  }
  animate();
</script>

</body>
</html>
