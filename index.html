<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>VexiT — Вызов транскодирования</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

  body {
    margin: 0;
    font-family: 'Share Tech Mono', monospace, 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    min-height: 100vh;
    background: #000;
    color: #eee;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    overflow-x: hidden;
    position: relative;
  }

  .network-canvas {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index: 0;
    background: #000;
  }

  header {
    font-size: 3rem;
    font-weight: 900;
    letter-spacing: 0.15em;
    margin-bottom: 10px;
    color: #66ccff;
    user-select: none;
    position: relative;
    z-index: 2;
    text-shadow:
      0 0 5px #66ccff,
      0 0 15px #66ccff;
  }
  header span {
    color: #ffaa00;
    text-shadow:
      0 0 8px #ffaa00,
      0 0 20px #ffaa00;
  }
  p.description {
    font-size: 1.1rem;
    max-width: 800px;
    margin-bottom: 18px;
    line-height: 1.45;
    text-align: center;
    position: relative;
    z-index: 2;
  }
  .translator {
    background: rgba(255 255 255 / 0.06);
    padding: 18px;
    border-radius: 12px;
    box-shadow:
      0 0 18px #ffaa00cc,
      inset 0 0 12px #ffaa00bb;
    width: 100%;
    max-width: 820px;
    position: relative;
    z-index: 2;
    transition: box-shadow 0.6s ease-in-out;
  }
  .translator:hover { box-shadow: 0 0 28px #ffbb33dd, inset 0 0 22px #ffbb33dd; }
  label { font-weight: 700; display: block; margin-bottom: 6px; color: #ffaa00; }
  textarea, select {
    width: 100%; padding: 12px 15px; font-size: 1rem; border-radius: 8px; border: none;
    background: #0f1a22; color: #eee; resize: vertical; box-sizing: border-box;
    box-shadow: inset 0 0 6px #223344aa; font-family: 'Share Tech Mono', monospace; transition: box-shadow 0.25s;
  }
  textarea:focus, select:focus { outline: none; box-shadow: 0 0 15px #ffaa00cc, inset 0 0 10px #ffaa00cc; background: #12232b; }
  textarea { min-height: 110px; margin-bottom: 14px; }
  .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; align-items: center; }
  button.translate-btn { background-color: #ffaa00; border: none; color: #111; font-size: 1.05rem; font-weight: 700; padding: 12px 18px; border-radius: 12px; cursor: pointer; box-shadow: 0 0 10px #ffaa00aa; transition: all 0.3s ease; }
  button.translate-btn:hover { transform: scale(1.05); background-color:#ffbb33; box-shadow: 0 0 15px #ffaa00; }
  button.translate-btn:active{ transform: translateY(1px);} 
  #output { margin-top: 16px; background: #07121a; padding: 14px; border-radius: 10px; min-height: 120px; white-space: pre-wrap; font-family: 'Share Tech Mono', monospace; color: #ccf3ff; box-shadow: inset 0 0 12px #33aaff66; }
  footer { margin-top: 18px; font-size: 0.85rem; color: #999; padding: 10px 0; text-align: center; width: 100%; position: relative; z-index: 2; }
  a { color: #66ccff; }
  .note { font-size:0.9rem; color:#bcd; margin-bottom:10px }
</style>
</head>
<body>

<header>Vex<span>i</span>T</header>

<p class="description">Онлайн-сервис для перевода текста в реальные и экспериментальные системы кодирования. <strong>Двоичный</strong> и <strong>шестнадцатеричный</strong> коды работают как в настоящем программировании (UTF‑8 байты). Остальные — экспериментальные форматы, похожие на двоичный, кроме инопланетного.</p>

<div class="translator" id="translator">
  <label for="textInput">Введите текст для перевода или декодирования:</label>
  <textarea id="textInput" placeholder="Например: Привет, мир!"></textarea>

  <div class="controls">
    <div>
      <label for="baseSelect">Выберите систему кодирования:</label>
      <select id="baseSelect">
        <option value="2" selected>Двоичный (реальный, UTF-8, 8 бит)</option>
        <option value="16">Шестнадцатеричный (реальный, UTF-8, слитно)</option>
        <option value="3">Троичный (экспериментальный)</option>
        <option value="4">Четвертичный (экспериментальный)</option>
        <option value="5">Пятеричный (экспериментальный)</option>
        <option value="6">Шестеричный (экспериментальный)</option>
        <option value="custom">Инопланетный код (основание 7)</option>
      </select>
    </div>

    <div>
      <label style="visibility:hidden">x</label>
      <div style="display:flex;gap:8px;align-items:center">
        <div style="flex:1">
          <select id="versionSelect">
            <option value="vertical" selected>Вертикальная (по символу)</option>
            <option value="horizontal">Горизонтальная (поток)</option>
          </select>
        </div>
        <div style="display:flex;align-items:center;gap:8px">
          <input type="checkbox" id="decodeToggle" />
          <label for="decodeToggle" style="user-select:none;color:#99e6ff">Декодировать</label>
        </div>
      </div>
    </div>
  </div>

  <div style="margin-top:12px;display:flex;gap:8px">
    <button class="translate-btn" id="runBtn">Выполнить</button>
    <button class="translate-btn" id="clearBtn" style="background:#223344;color:#ccf3ff">Сброс</button>
  </div>

  <div class="note">Примечание: для двоичного и шестнадцатеричного кодирования используется <em>UTF-8 байтовая</em> модель — это значит, что для нелатинских символов (например, кириллицы) каждый символ может превращаться в несколько байт. Бинарные байты отображаются по 8 бит; HEX — слитно (без пробелов) при горизонтальном варианте.</div>

  <pre id="output"></pre>
</div>

<canvas class="network-canvas" id="networkCanvas"></canvas>

<footer>
  © 2025 VexiT. Все права защищены.<br>
  Контакты: <a href="https://t.me/corecmd" target="_blank" rel="noopener noreferrer">@corecmd</a>
</footer>

<script>
// --- 3D сетевой фон с точками ---
(function(){
  const canvas = document.getElementById('networkCanvas');
  const ctx = canvas.getContext('2d');
  let w, h;
  function resize(){ w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; }
  window.addEventListener('resize', resize); resize();

  const nodes = Array.from({length: 120}, () => ({
    x: (Math.random()-0.5)*2,
    y: (Math.random()-0.5)*2,
    z: (Math.random())*2+0.2
  }));

  function project3D(node){
    const scale = 300;
    const perspective = 1/(node.z);
    return {
      x: w/2 + node.x*scale*perspective,
      y: h/2 + node.y*scale*perspective,
      size: Math.max(1, 3*perspective)
    };
  }

  function animate(){
    ctx.clearRect(0,0,w,h);
    for(let i=0;i<nodes.length;i++){
      const n=nodes[i];
      n.z -= 0.01;
      if(n.z<=0.1){ n.z=2; n.x=(Math.random()-0.5)*2; n.y=(Math.random()-0.5)*2; }
      const p = project3D(n);
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.size,0,Math.PI*2);
      ctx.fillStyle='#0ff';
      ctx.fill();
      for(let j=i+1;j<nodes.length;j++){
        const m=nodes[j];
        const dx=n.x-m.x, dy=n.y-m.y, dz=n.z-m.z;
        const dist=Math.sqrt(dx*dx+dy*dy+dz*dz);
        if(dist<0.4){
          const p2=project3D(m);
          ctx.strokeStyle=`rgba(0,255,255,${1-dist/0.4})`;
          ctx.beginPath();
          ctx.moveTo(p.x,p.y);
          ctx.lineTo(p2.x,p2.y);
          ctx.stroke();
        }
      }
    }
    requestAnimationFrame(animate);
  }
  animate();
})();
</script>

<script>
// --- Основной конвертер ---
(function(){
  const customSymbols = ['0', '∆', '⧫', '☌', '⚛', '✦', '※'];

  function toCustomBase(num, baseSymbols) {
    const base = baseSymbols.length;
    if (num === 0) return baseSymbols[0];
    let result = '';
    let n = num;
    while (n > 0) {
      const digit = n % base;
      result = baseSymbols[digit] + result;
      n = Math.floor(n / base);
    }
    return result;
  }

  function getPadLength(base) {
    if (base === 'custom') return 4;
    if (Number(base) === 2) return 8;
    if (Number(base) === 16) return 2;
    const baseNum = Number(base);
    return Math.ceil(Math.log(65535) / Math.log(baseNum));
  }

  function splitCodes(inputStr, padLength, base, version) {
    const codes = [];
    if (!inputStr) return codes;
    if (version === 'vertical') {
      const lines = inputStr.trim().split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      lines.forEach(line => {
        // Для декодирования в вертикальном режиме извлекаем только коды (после →)
        if (line.includes('→')) {
          line = line.split('→')[1].trim();
        }
        
        if ((base === '2' || base === '16') && !/\s/.test(line)) {
          for (let i = 0; i < line.length; i += padLength) {
            codes.push(line.slice(i, i + padLength));
          }
        } else {
          line.split(/\s+/).forEach(tok => { if (tok) codes.push(tok); });
        }
      });
    } else {
      const joined = inputStr.replace(/\s+/g, '');
      for (let i = 0; i < joined.length; i += padLength) {
        codes.push(joined.slice(i, i + padLength));
      }
    }
    return codes;
  }

  function fromCustomBaseSafe(str) {
    const base = customSymbols.length;
    if (!str) return null;
    let result = 0;
    for (let i = 0; i < str.length; i++) {
      const digit = customSymbols.indexOf(str[i]);
      if (digit === -1) return null;
      result = result * base + digit;
    }
    return result;
  }

  function convert() {
    const input = document.getElementById('textInput').value;
    const base = document.getElementById('baseSelect').value;
    const output = document.getElementById('output');
    const decode = document.getElementById('decodeToggle').checked;
    const version = document.getElementById('versionSelect').value;

    if (!input) {
      output.textContent = 'Пожалуйста, введите текст для перевода или декодирования.';
      return;
    }

    const padLength = getPadLength(base);
    let result = '';

    try {
      if (!decode) {
        // Режим кодирования
        if (base === 'custom') {
          if (version === 'vertical') {
            for (const ch of [...input]) {
              const cp = ch.codePointAt(0);
              const encoded = toCustomBase(cp, customSymbols).padStart(padLength, customSymbols[0]);
              result += `${ch} → ${encoded}\n`;
            }
          } else {
            const codes = [...input].map(ch => toCustomBase(ch.codePointAt(0), customSymbols).padStart(padLength, customSymbols[0]));
            result = codes.join(' ');
          }
        } else if (Number(base) === 2 || Number(base) === 16) {
          const encoder = new TextEncoder();
          if (version === 'vertical') {
            for (const ch of [...input]) {
              const bytes = Array.from(encoder.encode(ch));
              if (Number(base) === 2) {
                const encoded = bytes.map(b => b.toString(2).padStart(8, '0')).join(' ');
                result += `${ch} → ${encoded}\n`;
              } else {
                const encoded = bytes.map(b => b.toString(16).toUpperCase().padStart(2, '0')).join('');
                result += `${ch} → ${encoded}\n`;
              }
            }
          } else {
            const allBytes = Array.from(encoder.encode(input));
            if (Number(base) === 2) {
              result = allBytes.map(b => b.toString(2).padStart(8, '0')).join(' ');
            } else {
              result = allBytes.map(b => b.toString(16).toUpperCase().padStart(2, '0')).join('');
            }
          }
        } else {
          const baseNum = Number(base);
          if (version === 'vertical') {
            for (const ch of [...input]) {
              const cp = ch.codePointAt(0);
              const encoded = cp.toString(baseNum).padStart(padLength, '0');
              result += `${ch} → ${encoded}\n`;
            }
          } else {
            const codes = [...input].map(ch => ch.codePointAt(0).toString(baseNum).padStart(padLength, '0'));
            result = codes.join(' ');
          }
        }
      } else {
        // Режим декодирования
        if (base === 'custom') {
          const codes = splitCodes(input, padLength, base, version);
          const chars = codes.map(codeStr => {
            const num = fromCustomBaseSafe(codeStr);
            if (num === null) throw new Error(`Некорректный кастомный код: ${codeStr}`);
            return String.fromCodePoint(num);
          });
          result = chars.join('');
        } else if (Number(base) === 2 || Number(base) === 16) {
          const codes = splitCodes(input, padLength, base, version);
          if (codes.length === 0) {
            output.textContent = 'Нет кодов для декодирования.';
            return;
          }
          
          const bytes = codes.map(s => {
            const num = parseInt(s, Number(base));
            if (isNaN(num) || num < 0 || num > 255) {
              throw new Error(`Некорректный байт: ${s}`);
            }
            return num;
          });
          
          const byteArray = new Uint8Array(bytes);
          const decoder = new TextDecoder('utf-8');
          result = decoder.decode(byteArray);
        } else {
          const baseNum = Number(base);
          const codes = splitCodes(input, padLength, base, version);
          const chars = codes.map(codeStr => {
            const num = parseInt(codeStr, baseNum);
            if (isNaN(num)) throw new Error(`Некорректный код: ${codeStr}`);
            return String.fromCodePoint(num);
          });
          result = chars.join('');
        }
      }
      
      output.textContent = result;
    } catch (error) {
      output.textContent = `Ошибка: ${error.message}`;
    }
  }

  // Назначение обработчиков событий
  document.getElementById('runBtn').addEventListener('click', convert);
  document.getElementById('clearBtn').addEventListener('click', function() {
    document.getElementById('textInput').value = '';
    document.getElementById('output').textContent = '';
  });
})();
</script>
</body>
</html>
